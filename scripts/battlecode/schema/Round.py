# automatically generated by the FlatBuffers compiler, do not modify

# namespace: schema

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# A single time-step in a Game.
# The bulk of the data in the file is stored in tables like this.
# Note that a struct-of-arrays format is more space efficient than an array-
# of-structs.
class Round(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Round()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsRound(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Round
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # The IDs of teams in the Game.
    # Round
    def TeamIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def TeamIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def TeamIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def TeamIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # The total amount of Ad change of this team, this round
    # Round
    def TeamAdChanges(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def TeamAdChangesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def TeamAdChangesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def TeamAdChangesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # The total amount of Mn change of this team, this round
    # Round
    def TeamMnChanges(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def TeamMnChangesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def TeamMnChangesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def TeamMnChangesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        return o == 0

    # The total amount of Ex change of this team, this round
    # Round
    def TeamExChanges(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def TeamExChangesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def TeamExChangesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def TeamExChangesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        return o == 0

    # The IDs of bodies that moved.
    # Round
    def MovedIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def MovedIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def MovedIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def MovedIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        return o == 0

    # The new locations of bodies that have moved.
    # Round
    def MovedLocs(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from battlecode.schema.VecTable import VecTable
            obj = VecTable()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # New bodies.
    # Round
    def SpawnedBodies(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from battlecode.schema.SpawnedBodyTable import SpawnedBodyTable
            obj = SpawnedBodyTable()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # The IDs of bodies that died.
    # Round
    def DiedIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def DiedIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def DiedIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def DiedIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # The IDs of robots that performed actions.
    # IDs may repeat.
    # Round
    def ActionIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def ActionIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def ActionIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def ActionIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        return o == 0

    # The actions performed. These actions allow us to track many things about the current state.
    # Round
    def Actions(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Round
    def ActionsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int8Flags, o)
        return 0

    # Round
    def ActionsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def ActionsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        return o == 0

    # The 'targets' of the performed actions. Actions without targets may have any value
    # Round
    def ActionTargets(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def ActionTargetsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def ActionTargetsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def ActionTargetsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        return o == 0

    # The IDs of all islands
    # Round
    def IslandIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def IslandIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def IslandIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def IslandIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

    # The number of turns the opposing team has been occupying each island
    # Round
    def IslandTurnoverTurns(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def IslandTurnoverTurnsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def IslandTurnoverTurnsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def IslandTurnoverTurnsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        return o == 0

    # The teamID for the owners of each island. 
    # Round
    def IslandOwnership(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def IslandOwnershipAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def IslandOwnershipLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def IslandOwnershipIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(30))
        return o == 0

    # The locations of the resources wells being given resources as x + y*width
    # Round
    def ResourceWellLocs(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def ResourceWellLocsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def ResourceWellLocsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def ResourceWellLocsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(32))
        return o == 0

    # The adamantium stored in the well
    # Round
    def WellAdamantiumValues(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def WellAdamantiumValuesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def WellAdamantiumValuesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def WellAdamantiumValuesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(34))
        return o == 0

    # The mana stored in the well
    # Round
    def WellManaValues(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def WellManaValuesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def WellManaValuesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def WellManaValuesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(36))
        return o == 0

    # The elixir stored in the well
    # Round
    def WellElixirValues(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def WellElixirValuesAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def WellElixirValuesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def WellElixirValuesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(38))
        return o == 0

    # The ID for the resource this well contains
    # Round
    def ResourceId(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def ResourceIdAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def ResourceIdLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def ResourceIdIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(40))
        return o == 0

    # The acceleration ID for this resource well: 1 is accelerated, 0 is not
    # Round
    def WellAccelerationId(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def WellAccelerationIdAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def WellAccelerationIdLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def WellAccelerationIdIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(42))
        return o == 0

    # The IDs of the robots who changed their indicator strings
    # Round
    def IndicatorStringIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(44))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def IndicatorStringIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(44))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def IndicatorStringIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(44))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def IndicatorStringIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(44))
        return o == 0

    # The messages of the robots who changed their indicator strings
    # Round
    def IndicatorStrings(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(46))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Round
    def IndicatorStringsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(46))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def IndicatorStringsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(46))
        return o == 0

    # The IDs of bodies that set indicator dots
    # Round
    def IndicatorDotIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(48))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def IndicatorDotIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(48))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def IndicatorDotIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(48))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def IndicatorDotIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(48))
        return o == 0

    # The location of the indicator dots
    # Round
    def IndicatorDotLocs(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(50))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from battlecode.schema.VecTable import VecTable
            obj = VecTable()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # The RGB values of the indicator dots
    # Round
    def IndicatorDotRgbs(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(52))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from battlecode.schema.RGBTable import RGBTable
            obj = RGBTable()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # The IDs of bodies that set indicator lines
    # Round
    def IndicatorLineIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(54))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def IndicatorLineIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(54))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def IndicatorLineIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(54))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def IndicatorLineIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(54))
        return o == 0

    # The start location of the indicator lines
    # Round
    def IndicatorLineStartLocs(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(56))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from battlecode.schema.VecTable import VecTable
            obj = VecTable()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # The end location of the indicator lines
    # Round
    def IndicatorLineEndLocs(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(58))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from battlecode.schema.VecTable import VecTable
            obj = VecTable()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # The RGB values of the indicator lines
    # Round
    def IndicatorLineRgbs(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(60))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from battlecode.schema.RGBTable import RGBTable
            obj = RGBTable()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # The first sent Round in a match should have index 1. (The starting state,
    # created by the MatchHeader, can be thought to have index 0.)
    # It should increase by one for each following round.
    # Round
    def RoundId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(62))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # The IDs of player bodies.
    # Round
    def BytecodeIds(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(64))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def BytecodeIdsAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(64))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def BytecodeIdsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(64))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def BytecodeIdsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(64))
        return o == 0

    # The bytecodes used by the player bodies.
    # Round
    def BytecodesUsed(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(66))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int32Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return 0

    # Round
    def BytecodesUsedAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(66))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int32Flags, o)
        return 0

    # Round
    def BytecodesUsedLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(66))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Round
    def BytecodesUsedIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(66))
        return o == 0

def RoundStart(builder): builder.StartObject(32)
def Start(builder):
    return RoundStart(builder)
def RoundAddTeamIds(builder, teamIds): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(teamIds), 0)
def AddTeamIds(builder, teamIds):
    return RoundAddTeamIds(builder, teamIds)
def RoundStartTeamIdsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartTeamIdsVector(builder, numElems):
    return RoundStartTeamIdsVector(builder, numElems)
def RoundAddTeamAdChanges(builder, teamAdChanges): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(teamAdChanges), 0)
def AddTeamAdChanges(builder, teamAdChanges):
    return RoundAddTeamAdChanges(builder, teamAdChanges)
def RoundStartTeamAdChangesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartTeamAdChangesVector(builder, numElems):
    return RoundStartTeamAdChangesVector(builder, numElems)
def RoundAddTeamMnChanges(builder, teamMnChanges): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(teamMnChanges), 0)
def AddTeamMnChanges(builder, teamMnChanges):
    return RoundAddTeamMnChanges(builder, teamMnChanges)
def RoundStartTeamMnChangesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartTeamMnChangesVector(builder, numElems):
    return RoundStartTeamMnChangesVector(builder, numElems)
def RoundAddTeamExChanges(builder, teamExChanges): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(teamExChanges), 0)
def AddTeamExChanges(builder, teamExChanges):
    return RoundAddTeamExChanges(builder, teamExChanges)
def RoundStartTeamExChangesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartTeamExChangesVector(builder, numElems):
    return RoundStartTeamExChangesVector(builder, numElems)
def RoundAddMovedIds(builder, movedIds): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(movedIds), 0)
def AddMovedIds(builder, movedIds):
    return RoundAddMovedIds(builder, movedIds)
def RoundStartMovedIdsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartMovedIdsVector(builder, numElems):
    return RoundStartMovedIdsVector(builder, numElems)
def RoundAddMovedLocs(builder, movedLocs): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(movedLocs), 0)
def AddMovedLocs(builder, movedLocs):
    return RoundAddMovedLocs(builder, movedLocs)
def RoundAddSpawnedBodies(builder, spawnedBodies): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(spawnedBodies), 0)
def AddSpawnedBodies(builder, spawnedBodies):
    return RoundAddSpawnedBodies(builder, spawnedBodies)
def RoundAddDiedIds(builder, diedIds): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(diedIds), 0)
def AddDiedIds(builder, diedIds):
    return RoundAddDiedIds(builder, diedIds)
def RoundStartDiedIdsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartDiedIdsVector(builder, numElems):
    return RoundStartDiedIdsVector(builder, numElems)
def RoundAddActionIds(builder, actionIds): builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(actionIds), 0)
def AddActionIds(builder, actionIds):
    return RoundAddActionIds(builder, actionIds)
def RoundStartActionIdsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartActionIdsVector(builder, numElems):
    return RoundStartActionIdsVector(builder, numElems)
def RoundAddActions(builder, actions): builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(actions), 0)
def AddActions(builder, actions):
    return RoundAddActions(builder, actions)
def RoundStartActionsVector(builder, numElems): return builder.StartVector(1, numElems, 1)
def StartActionsVector(builder, numElems):
    return RoundStartActionsVector(builder, numElems)
def RoundAddActionTargets(builder, actionTargets): builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(actionTargets), 0)
def AddActionTargets(builder, actionTargets):
    return RoundAddActionTargets(builder, actionTargets)
def RoundStartActionTargetsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartActionTargetsVector(builder, numElems):
    return RoundStartActionTargetsVector(builder, numElems)
def RoundAddIslandIds(builder, islandIds): builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(islandIds), 0)
def AddIslandIds(builder, islandIds):
    return RoundAddIslandIds(builder, islandIds)
def RoundStartIslandIdsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartIslandIdsVector(builder, numElems):
    return RoundStartIslandIdsVector(builder, numElems)
def RoundAddIslandTurnoverTurns(builder, islandTurnoverTurns): builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(islandTurnoverTurns), 0)
def AddIslandTurnoverTurns(builder, islandTurnoverTurns):
    return RoundAddIslandTurnoverTurns(builder, islandTurnoverTurns)
def RoundStartIslandTurnoverTurnsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartIslandTurnoverTurnsVector(builder, numElems):
    return RoundStartIslandTurnoverTurnsVector(builder, numElems)
def RoundAddIslandOwnership(builder, islandOwnership): builder.PrependUOffsetTRelativeSlot(13, flatbuffers.number_types.UOffsetTFlags.py_type(islandOwnership), 0)
def AddIslandOwnership(builder, islandOwnership):
    return RoundAddIslandOwnership(builder, islandOwnership)
def RoundStartIslandOwnershipVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartIslandOwnershipVector(builder, numElems):
    return RoundStartIslandOwnershipVector(builder, numElems)
def RoundAddResourceWellLocs(builder, resourceWellLocs): builder.PrependUOffsetTRelativeSlot(14, flatbuffers.number_types.UOffsetTFlags.py_type(resourceWellLocs), 0)
def AddResourceWellLocs(builder, resourceWellLocs):
    return RoundAddResourceWellLocs(builder, resourceWellLocs)
def RoundStartResourceWellLocsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartResourceWellLocsVector(builder, numElems):
    return RoundStartResourceWellLocsVector(builder, numElems)
def RoundAddWellAdamantiumValues(builder, wellAdamantiumValues): builder.PrependUOffsetTRelativeSlot(15, flatbuffers.number_types.UOffsetTFlags.py_type(wellAdamantiumValues), 0)
def AddWellAdamantiumValues(builder, wellAdamantiumValues):
    return RoundAddWellAdamantiumValues(builder, wellAdamantiumValues)
def RoundStartWellAdamantiumValuesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartWellAdamantiumValuesVector(builder, numElems):
    return RoundStartWellAdamantiumValuesVector(builder, numElems)
def RoundAddWellManaValues(builder, wellManaValues): builder.PrependUOffsetTRelativeSlot(16, flatbuffers.number_types.UOffsetTFlags.py_type(wellManaValues), 0)
def AddWellManaValues(builder, wellManaValues):
    return RoundAddWellManaValues(builder, wellManaValues)
def RoundStartWellManaValuesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartWellManaValuesVector(builder, numElems):
    return RoundStartWellManaValuesVector(builder, numElems)
def RoundAddWellElixirValues(builder, wellElixirValues): builder.PrependUOffsetTRelativeSlot(17, flatbuffers.number_types.UOffsetTFlags.py_type(wellElixirValues), 0)
def AddWellElixirValues(builder, wellElixirValues):
    return RoundAddWellElixirValues(builder, wellElixirValues)
def RoundStartWellElixirValuesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartWellElixirValuesVector(builder, numElems):
    return RoundStartWellElixirValuesVector(builder, numElems)
def RoundAddResourceId(builder, resourceId): builder.PrependUOffsetTRelativeSlot(18, flatbuffers.number_types.UOffsetTFlags.py_type(resourceId), 0)
def AddResourceId(builder, resourceId):
    return RoundAddResourceId(builder, resourceId)
def RoundStartResourceIdVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartResourceIdVector(builder, numElems):
    return RoundStartResourceIdVector(builder, numElems)
def RoundAddWellAccelerationId(builder, wellAccelerationId): builder.PrependUOffsetTRelativeSlot(19, flatbuffers.number_types.UOffsetTFlags.py_type(wellAccelerationId), 0)
def AddWellAccelerationId(builder, wellAccelerationId):
    return RoundAddWellAccelerationId(builder, wellAccelerationId)
def RoundStartWellAccelerationIdVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartWellAccelerationIdVector(builder, numElems):
    return RoundStartWellAccelerationIdVector(builder, numElems)
def RoundAddIndicatorStringIds(builder, indicatorStringIds): builder.PrependUOffsetTRelativeSlot(20, flatbuffers.number_types.UOffsetTFlags.py_type(indicatorStringIds), 0)
def AddIndicatorStringIds(builder, indicatorStringIds):
    return RoundAddIndicatorStringIds(builder, indicatorStringIds)
def RoundStartIndicatorStringIdsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartIndicatorStringIdsVector(builder, numElems):
    return RoundStartIndicatorStringIdsVector(builder, numElems)
def RoundAddIndicatorStrings(builder, indicatorStrings): builder.PrependUOffsetTRelativeSlot(21, flatbuffers.number_types.UOffsetTFlags.py_type(indicatorStrings), 0)
def AddIndicatorStrings(builder, indicatorStrings):
    return RoundAddIndicatorStrings(builder, indicatorStrings)
def RoundStartIndicatorStringsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartIndicatorStringsVector(builder, numElems):
    return RoundStartIndicatorStringsVector(builder, numElems)
def RoundAddIndicatorDotIds(builder, indicatorDotIds): builder.PrependUOffsetTRelativeSlot(22, flatbuffers.number_types.UOffsetTFlags.py_type(indicatorDotIds), 0)
def AddIndicatorDotIds(builder, indicatorDotIds):
    return RoundAddIndicatorDotIds(builder, indicatorDotIds)
def RoundStartIndicatorDotIdsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartIndicatorDotIdsVector(builder, numElems):
    return RoundStartIndicatorDotIdsVector(builder, numElems)
def RoundAddIndicatorDotLocs(builder, indicatorDotLocs): builder.PrependUOffsetTRelativeSlot(23, flatbuffers.number_types.UOffsetTFlags.py_type(indicatorDotLocs), 0)
def AddIndicatorDotLocs(builder, indicatorDotLocs):
    return RoundAddIndicatorDotLocs(builder, indicatorDotLocs)
def RoundAddIndicatorDotRgbs(builder, indicatorDotRgbs): builder.PrependUOffsetTRelativeSlot(24, flatbuffers.number_types.UOffsetTFlags.py_type(indicatorDotRgbs), 0)
def AddIndicatorDotRgbs(builder, indicatorDotRgbs):
    return RoundAddIndicatorDotRgbs(builder, indicatorDotRgbs)
def RoundAddIndicatorLineIds(builder, indicatorLineIds): builder.PrependUOffsetTRelativeSlot(25, flatbuffers.number_types.UOffsetTFlags.py_type(indicatorLineIds), 0)
def AddIndicatorLineIds(builder, indicatorLineIds):
    return RoundAddIndicatorLineIds(builder, indicatorLineIds)
def RoundStartIndicatorLineIdsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartIndicatorLineIdsVector(builder, numElems):
    return RoundStartIndicatorLineIdsVector(builder, numElems)
def RoundAddIndicatorLineStartLocs(builder, indicatorLineStartLocs): builder.PrependUOffsetTRelativeSlot(26, flatbuffers.number_types.UOffsetTFlags.py_type(indicatorLineStartLocs), 0)
def AddIndicatorLineStartLocs(builder, indicatorLineStartLocs):
    return RoundAddIndicatorLineStartLocs(builder, indicatorLineStartLocs)
def RoundAddIndicatorLineEndLocs(builder, indicatorLineEndLocs): builder.PrependUOffsetTRelativeSlot(27, flatbuffers.number_types.UOffsetTFlags.py_type(indicatorLineEndLocs), 0)
def AddIndicatorLineEndLocs(builder, indicatorLineEndLocs):
    return RoundAddIndicatorLineEndLocs(builder, indicatorLineEndLocs)
def RoundAddIndicatorLineRgbs(builder, indicatorLineRgbs): builder.PrependUOffsetTRelativeSlot(28, flatbuffers.number_types.UOffsetTFlags.py_type(indicatorLineRgbs), 0)
def AddIndicatorLineRgbs(builder, indicatorLineRgbs):
    return RoundAddIndicatorLineRgbs(builder, indicatorLineRgbs)
def RoundAddRoundId(builder, roundId): builder.PrependInt32Slot(29, roundId, 0)
def AddRoundId(builder, roundId):
    return RoundAddRoundId(builder, roundId)
def RoundAddBytecodeIds(builder, bytecodeIds): builder.PrependUOffsetTRelativeSlot(30, flatbuffers.number_types.UOffsetTFlags.py_type(bytecodeIds), 0)
def AddBytecodeIds(builder, bytecodeIds):
    return RoundAddBytecodeIds(builder, bytecodeIds)
def RoundStartBytecodeIdsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartBytecodeIdsVector(builder, numElems):
    return RoundStartBytecodeIdsVector(builder, numElems)
def RoundAddBytecodesUsed(builder, bytecodesUsed): builder.PrependUOffsetTRelativeSlot(31, flatbuffers.number_types.UOffsetTFlags.py_type(bytecodesUsed), 0)
def AddBytecodesUsed(builder, bytecodesUsed):
    return RoundAddBytecodesUsed(builder, bytecodesUsed)
def RoundStartBytecodesUsedVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartBytecodesUsedVector(builder, numElems):
    return RoundStartBytecodesUsedVector(builder, numElems)
def RoundEnd(builder): return builder.EndObject()
def End(builder):
    return RoundEnd(builder)